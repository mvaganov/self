### A student of software development learns ...
* **attention to detail** - that instructions and information can be misunderstood, and being exact results in consistent performance. Working with syntax errors easily teaches this. C.S. students often notice their grammar and spelling habits changing from this exposure, even from just a few weeks of practice.
* **grit** - to accept error and imperfection as a natural part of learning, and to forgive-oneself quickly, so that progress can be made. Practicing anything improves grit, but practicing a task that constantly identifies that you are wrong, in cryptic-but-eventually-understantable ways, does it especially well.
* **to quickly test things out (rapid-prototyping)** - that writing and testing software is cheap, even when it fails. Having results from lots of quickly-done-and-*incorrect* solutions is a great guide toward a *correct*-solution. This is how progress is made in the real world. Lab-based Computer Science assignments teach this way, by having students create lots of new pieces of code from scratch.
* **anything can be understood** - that even incomprehensible systems can be understood one small piece at a time. This realization is one that creeps up on a person, and it comes once enough previously-incomprehensible-systems become comfortably unterstood. Once established, it provides an intellectual confidence that is hard to shake.
* **how to understand *un*intuitive ideas** - that software works in ways that are not always easy to understand, but are still true, and eventually understandable. Comfort with specifically *unintuitive* ideas also acts as a defense against a variety of cognative biases, like stereotyping, and the-band-wagon effect.
* **stronger habits of problem solving** - that solving-a-problem is satisfying and encouraging, and anyone is capable of solving a problem. The world needs more problem solvers, and computer programming is all about how to solve problems with a computer.
* **new mental tools** - solving software problems requires development of mental tools not required by many other fields of study, but still useful to them. Computer-programming mental-tools like breaking-problems-down-into-specific-steps, strict logical reasoning, recursive thinking, object-oriented-composition, abstraction, and others. These mental tools can be easy to practice with programming.
* **confidence as a computer user** - that practice with computers alone makes someone better with computers. And there is a need for more confident computer users today, and in the future.
* **to think-about-thinking (metacognition)** - that creating-an-algorithm requires introspection: awareness of your own thought process, enough that you can name and list your own thoughts. Programming does not make metacognition easy, but it does provide a metacognitive exercise with testable results.
* **faith and skill in science** - that hypothesis testing, the cornerstone of science, is an effective tool for developing human knowledge. This is such a regular part of computer-science that it's easy to miss. Every time a teacher asks "What does this code do?" or a student says "I think this will work", there is hypothesis testing going on.
* **metacognitive awareness** - that the ability to think is determined by mental state, and *managing mental state* (with food, sleep, addressing emotional issues, ...) is a foundation for successful problem solving. Programming does not make this obvious, but being aware of the tangible-results-of-programming, done in various mental states, does.
* **fearlessness of computers** - that a computer is just a tool, with no emotions, no motives, no purpose beyond what it was designed to do, and the ability to multiply its programmer's intelligence and influence.
* **fail-fast** - the pholosophy of engineering: it is good to fail an entire-process the moment some small part is incorrect, so it *will* be fixed, and the process can be perfect sooner. Programmers are exposed to this philosophy constantly, because great software is built on this idea.
* **understanding is power** - that correctly-understanding-a-problem, all by itself, is almost enough to solve it. Correctly understanding a system is almost enough to influence it's behavior, which is clearly evident with computer programming.
